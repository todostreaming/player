/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <libgen.h>
#include <signal.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <iostream>

#include "Play.h"
#include "VideoFrame3D.h"

#define TIMEOUT			1   // 1 second timeout

pthread_mutex_t            sleepMutex;
pthread_cond_t            sleepCond;
bool                    do_exit = false;

const unsigned long        kAudioWaterlevel = 48000;

static FILE 			*fp_audio = NULL;
static FILE 			*fp_video = NULL;

void alarm_handler (int sig)
{
    std::cerr << "Timeout overcome !!!!\n";
    std::cerr << "Badly Exiting ....\n";
//  closefiles();
    exit (1);
}

void sigfunc(int signum)
{
    if (signum == SIGINT || signum == SIGTERM) {
        do_exit = true;
    }
    pthread_cond_signal(&sleepCond);
}

int main(int argc, char *argv[])
{
	pthread_mutex_init(&sleepMutex, NULL);
    pthread_cond_init(&sleepCond, NULL);

    signal(SIGINT, sigfunc);
    signal(SIGTERM, sigfunc);
    signal(SIGHUP, sigfunc);

    signal (SIGALRM, alarm_handler);

    BMDConfig config;
    if (!config.ParseArguments(argc, argv))
    {
        config.DisplayUsage(1);
        return 1;
    }

    if (!(fp_video = fopen (config.m_videoOutputFile, "r+")))
    {
        std::cerr << "Error: could not open video stream file '"
                    << config.m_videoOutputFile << "': "
                    << "\n";
        exit (1);
    }
	if (!(fp_audio = fopen (config.m_audioOutputFile, "r+")))
	{
		std::cerr << "Error: could not open audio stream file '"
					<< config.m_audioOutputFile << "': "
					<< "\n";
		exit (1);
	}
	fprintf(stderr,"Opening Video File: %s\nOpening Audio File: %s\n",config.m_videoOutputFile,config.m_audioOutputFile);
    alarm (TIMEOUT);

    TestPattern generator(&config);

    if (!generator.Init())
        return 1;

    return 0;
}

TestPattern::TestPattern(BMDConfig *config) :
    m_config(config),
    m_running(false),
    m_deckLink(),
    m_deckLinkOutput(),
    m_displayMode(),
    m_videoFrameBlack(),
    m_videoFrameBars(),
    m_outputSignal(kOutputSignalDrop),
    m_audioBuffer(),
    m_audioSampleRate(bmdAudioSampleRate48kHz)
{
}

bool TestPattern::Init()
{
    HRESULT                            result;
    int                                idx;
    bool                            success = false;

    IDeckLinkIterator*                deckLinkIterator = NULL;
    IDeckLinkDisplayModeIterator*    displayModeIterator = NULL;
    char*                            displayModeName = NULL;

    // Get the DeckLink device
    deckLinkIterator = CreateDeckLinkIteratorInstance();
    if (!deckLinkIterator)
    {
        fprintf(stderr, "This application requires the DeckLink drivers installed.\n");
        goto bail;
    }

    idx = m_config->m_deckLinkIndex;

    while ((result = deckLinkIterator->Next(&m_deckLink)) == S_OK)
    {
        if (idx == 0)
            break;
        --idx;

        m_deckLink->Release();
    }

    if (result != S_OK || m_deckLink == NULL)
    {
        fprintf(stderr, "Unable to get DeckLink device %u\n", m_config->m_deckLinkIndex);
        goto bail;
    }

    // Get the output (display) interface of the DeckLink device
    if (m_deckLink->QueryInterface(IID_IDeckLinkOutput, (void**)&m_deckLinkOutput) != S_OK)
        goto bail;

    // Get the display mode
    idx = m_config->m_displayModeIndex;

    result = m_deckLinkOutput->GetDisplayModeIterator(&displayModeIterator);
    if (result != S_OK)
        goto bail;

    while ((result = displayModeIterator->Next(&m_displayMode)) == S_OK)
    {
        if (idx == 0)
            break;
        --idx;

        m_displayMode->Release();
    }

    if (result != S_OK || m_displayMode == NULL)
    {
        fprintf(stderr, "Unable to get display mode %d\n", m_config->m_displayModeIndex);
        goto bail;
    }

    // Get display mode name
    result = m_displayMode->GetName((const char**)&displayModeName);
    if (result != S_OK)
    {
        displayModeName = (char *)malloc(32);
        snprintf(displayModeName, 32, "[index %d]", m_config->m_displayModeIndex);
    }

    // Check for 3D support on display mode
    if ((m_config->m_outputFlags & bmdVideoOutputDualStream3D) && !(m_displayMode->GetFlags() & bmdDisplayModeSupports3D))
    {
        fprintf(stderr, "The display mode %s is not supported with 3D\n", displayModeName);
        goto bail;
    }

    m_config->DisplayConfiguration();

    // Provide this class as a delegate to the audio and video output interfaces
    m_deckLinkOutput->SetScheduledFrameCompletionCallback(this);
    m_deckLinkOutput->SetAudioCallback(this);

    success = true;

    // Start.
    while (!do_exit)
    {
        StartRunning();
        fprintf(stderr, "Starting playback\n");

        pthread_mutex_lock(&sleepMutex);
        pthread_cond_wait(&sleepCond, &sleepMutex);
        pthread_mutex_unlock(&sleepMutex);

        fprintf(stderr, "Stopping playback\n");
        StopRunning();
    }

    printf("\n");

    m_running = false;

bail:
    if (displayModeName != NULL)
        free(displayModeName);

    if (m_displayMode != NULL)
        m_displayMode->Release();

    if (displayModeIterator != NULL)
        displayModeIterator->Release();

    if (m_deckLinkOutput != NULL)
        m_deckLinkOutput->Release();

    if (m_deckLink != NULL)
        m_deckLink->Release();

    if (deckLinkIterator != NULL)
        deckLinkIterator->Release();

    return success;
}

void TestPattern::StartRunning()
{
    HRESULT                    result;
    unsigned long            audioSamplesPerFrame;
    IDeckLinkVideoFrame*    rightFrame;
    VideoFrame3D*            frame3D;

    m_frameWidth = m_displayMode->GetWidth();
    m_frameHeight = m_displayMode->GetHeight();
    m_displayMode->GetFrameRate(&m_frameDuration, &m_frameTimescale);

    // Calculate the number of frames per second, rounded up to the nearest integer.  For example, for NTSC (29.97 FPS), framesPerSecond == 30.
    m_framesPerSecond = (unsigned long)((m_frameTimescale + (m_frameDuration-1))  /  m_frameDuration);

    // Set the video output mode
    result = m_deckLinkOutput->EnableVideoOutput(m_displayMode->GetDisplayMode(), m_config->m_outputFlags);
    if (result != S_OK)
    {
        fprintf(stderr, "Failed to enable video output. Is another application using the card?\n");
        goto bail;
    }

    // Set the audio output mode
    result = m_deckLinkOutput->EnableAudioOutput(bmdAudioSampleRate48kHz, m_config->m_audioSampleDepth, m_config->m_audioChannels, bmdAudioOutputStreamContinuous);
    if (result != S_OK)
    {
        fprintf(stderr, "Failed to enable audio output\n");
        goto bail;
    }

        // Begin video preroll by scheduling a second of frames in hardware
    m_totalFramesScheduled = 0;
    m_totalFramesDropped = 0;
    m_totalFramesCompleted = 0;
    for (unsigned i = 0; i < m_framesPerSecond; i++)
        ScheduleNextFrame(true);

    // Begin audio preroll.  This will begin calling our audio callback, which will start the DeckLink output stream.
    m_audioBufferOffset = 0;
    if (m_deckLinkOutput->BeginAudioPreroll() != S_OK)
    {
        fprintf(stderr, "Failed to begin audio preroll\n");
        goto bail;
    }

    m_running = true;

    return;

bail:
    // *** Error-handling code.  Cleanup any resources that were allocated. *** //
    StopRunning();
}

void TestPattern::StopRunning()
{
    // Stop the audio and video output streams immediately
    m_deckLinkOutput->StopScheduledPlayback(0, NULL, 0);
    //
    m_deckLinkOutput->DisableAudioOutput();
    m_deckLinkOutput->DisableVideoOutput();

    // Success; update the UI
    m_running = false;
}

void TestPattern::ScheduleNextFrame(bool prerolling)
{
    IDeckLinkMutableVideoFrame *frame = NULL;

    if (prerolling == false) {
        // If not prerolling, make sure that playback is still active
        if (m_running == false)
            return;
    }

    CreateFrame(&frame);

    m_deckLinkOutput->ScheduleVideoFrame(frame, (m_totalFramesScheduled++ * m_frameDuration), m_frameDuration, m_frameTimescale);

    frame->Release();
}

void TestPattern::WriteNextAudioSamples()
{
    unsigned int        bufferedSamples;

    // Try to maintain the number of audio samples buffered in the API at a specified waterlevel
    if ((m_deckLinkOutput->GetBufferedAudioSampleFrameCount(&bufferedSamples) == S_OK) && (bufferedSamples < kAudioWaterlevel))
    {
        unsigned int        samplesToEndOfBuffer;
        unsigned int        samplesToWrite;
        unsigned int        samplesWritten;
        void *              buf;


        samplesToWrite = (kAudioWaterlevel - bufferedSamples);

        buf = malloc(samplesToWrite * 2 * 2);

        //read(m_config->m_audio, buf, samplesToWrite * 2 * 2);
        fread (buf, 1, samplesToWrite * 2 * 2, fp_audio);
        fflush (fp_audio);

        if (m_deckLinkOutput->ScheduleAudioSamples(buf, samplesToWrite, 0, 0, &samplesWritten) == S_OK)
        {
            if (samplesToWrite != samplesWritten) {
                fprintf(stderr, "Audio desync");
                abort();
            }
        }
        free(buf);
    }
}

int GetBytesPerPixel(BMDPixelFormat pixelFormat)
{
    int bytesPerPixel = 2;

    switch(pixelFormat)
    {
    case bmdFormat8BitYUV:
        bytesPerPixel = 2;
        break;
    case bmdFormat8BitARGB:
    case bmdFormat10BitYUV:
    case bmdFormat10BitRGB:
        bytesPerPixel = 4;
        break;
    }

    return bytesPerPixel;
}

static void FillFromFD(IDeckLinkVideoFrame* theFrame, /*int fd,*/ BMDPixelFormat pixelFormat)
{
    void *buf;
    unsigned long    width;
    unsigned long    height;
    unsigned long    wordsRemaining;

    theFrame->GetBytes(&buf);
    width = theFrame->GetWidth();
    height = theFrame->GetHeight();

    //read(fd, buf, height * width * GetBytesPerPixel(pixelFormat));
	fread (buf, 1, height * width * GetBytesPerPixel(pixelFormat), fp_video);
	fflush (fp_video);

}


HRESULT TestPattern::CreateFrame(IDeckLinkMutableVideoFrame** frame)
{
    HRESULT                        result;
    int                            bytesPerPixel = GetBytesPerPixel(m_config->m_pixelFormat);
    IDeckLinkMutableVideoFrame*    newFrame = NULL;

    *frame = NULL;

    result = m_deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, m_frameWidth * bytesPerPixel, m_config->m_pixelFormat, bmdFrameFlagDefault, &newFrame);
    if (result != S_OK)
    {
        fprintf(stderr, "Failed to create video frame\n");
        goto bail;
    }

    FillFromFD(newFrame, /*m_config->m_video,*/ m_config->m_pixelFormat);

    *frame = newFrame;
    newFrame = NULL;

bail:
    if (newFrame != NULL)
        newFrame->Release();

    return result;
}

void TestPattern::PrintStatusLine()
{
    printf("scheduled %-16lu completed %-16lu dropped %-16lu\r",
        m_totalFramesScheduled, m_totalFramesCompleted, m_totalFramesDropped);
}

/************************* DeckLink API Delegate Methods *****************************/

HRESULT TestPattern::ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult result)
{
    ++m_totalFramesCompleted;
    PrintStatusLine();
    alarm (TIMEOUT);

    // When a video frame has been released by the API, schedule another video frame to be output
    ScheduleNextFrame(false);
    return S_OK;
}

HRESULT TestPattern::ScheduledPlaybackHasStopped()
{
    return S_OK;
}

HRESULT TestPattern::RenderAudioSamples(bool preroll)
{
    // Provide further audio samples to the DeckLink API until our preferred buffer waterlevel is reached
    WriteNextAudioSamples();

    if (preroll)
    {
        // Start audio and video output
        m_deckLinkOutput->StartScheduledPlayback(0, 100, 1.0);
    }

    return S_OK;
}

/*****************************************/

